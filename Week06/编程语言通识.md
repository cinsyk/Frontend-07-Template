# 编程语言通识

## 产生式
* 产生式： 在计算机中指 Tiger 编译器将源程序经过词法分析（Lexical Analysis）和语法分析（Syntax Analysis）后得到的一系列符合文法规则（Backus-Naur Form，BNF）的语句
* [巴科斯诺尔范式](https://zh.wikipedia.org/wiki/巴科斯范式)：即巴科斯范式（英语：Backus Normal Form，缩写为 BNF）是一种用于表示上下文无关文法的语言，上下文无关文法描述了一类形式语言。它是由约翰·巴科斯（John Backus）和彼得·诺尔（Peter Naur）首先引入的用来描述计算机语言语法的符号集。
* 终结符： 最终在代码中出现的字符（[ https://zh.wikipedia.org/wiki/ 終結符與非終結符](https://zh.wikipedia.org/wiki/終結符與非終結符))
* [乔姆斯基谱系](https://zh.wikipedia.org/wiki/乔姆斯基谱系)：是计算机科学中刻画形式文法表达能力的一个分类谱系，是由诺姆·乔姆斯基于 1956 年提出的。它包括四个层次：
  * 0- 型文法（无限制文法或短语结构文法）包括所有的文法。
  * 1- 型文法（上下文相关文法）生成上下文相关语言。
  * 2- 型文法（上下文无关文法）生成上下文无关语言。
  * 3- 型文法（正规文法）生成正则语言。

## 语言的分类

### 高级语言和低级语言

> 高级语言与低级语言的区别：高级语言大部分不能直接更硬件打交道，这使得相对来的程序运行速度降低，总之一句话来说那种语言更接近人性化的语言就更高级。

* 低级语言：机器码、汇编语言

  > 机器码：计算机能够直接识别的二级制编码，无论语言多高级都要转成二级制文件来让计算机识别运行。
  >
  > 汇编：用助记符（Mnemonics）代替机器指令的操作码，用地址符号（Symbol）或标号（Label）代替指令或操作数的地址，在不同的设备中有着不同的指令集

* 高级语言：c，c++，java，python，PHP，c#，Ruby，go，kotlin，swift。

  > 高级语言：为省去编程时候的不必要的操作细节，节省代码量，可读性强，维护性强，更贴近人性化

* 专用语言：SQL

  > 专注于某个应用程序领域的计算机语言

* 脚本语言：JavaScript

  > 为了缩短传统的编写-编译-链接-运行（edit-compile-link-run） 过程而创建的计算机编程语言。
  >
  > 脚本语言一般都 有相应的脚本引擎来解释执行。 

### 动态类型和静态类型

* 动态类型语言：Python，Ruby，Perl，JS，Lua……

  > 动态类型：在程序运行期间才给变量指定数据的类型

* 静态类型语言：C，C++，Rust，Java，C#，VB，TS，Switft，Kotlin，Pascal……

  > 静态类型：写程序代码的时候就要指定变量的类型

### 强类型与弱类型

> 强制类型更严谨，更不容易出现错误，但弱类型的语言写起来更优雅，更舒畅

* 强类型语言：Java，C，C#，Ruby，Clojure，Haskel，F#，TS……

  > 强类型：一个变量只能定义为一种类型，如float类型，那么它就只能是float类型而不能在不发生转化的情况下赋予int类型

* 弱类型语言：Python，VB，JS，Perl……

  > 弱类型：变量可以任意的赋值，没有类型的界限

* 混合类型语言：Rust，C++……

### 编译型，解释型，半编译半解释

* 编译型语言：C，C++，Rust，C#，XAML，ANLTR，IDL，TS，Switft，Kotlin，Pascal，F#，Latex……

  > 编译型：在执行程序中会将源文件一次性的转化为机器码。编译型语言是离不开解释程序的，这也导致了解释性语言在运行时候的速度比较慢，解释型语言只要有解释器，移植起来比较方便；

* 解释型语言：JSON，XML，HTML，SQL，CSS，YAML，MarkDown，Python，Ruby，Perl，Python，JavaScript，shell

  > 解释型：在执行程序中边编译边解释，要对不同的系统进行编译，编译工作繁琐，在调试程序的时候比较慢

* 半编译半解释型语言：Java

  > 半编译半解释型：编译时将源文件转化为字节码，在程序运行的时候转化为二进制文件。
  >
  > 注： java是“一次编译，到处执行”，c#是“一次编码，到处编译”。

### 面向对象型和面向过程型

* 面向过程：c

  > 决定该怎么铺成一条路到达终点，

* 面向对象：java, c++

  > 要用那些具有特定功能的像来做

### 数据描述语言和编程语言

* 数据描述语言：JSON，XML，XAML，HTML，SQL，CSS，YAML，ANLTR，MarkDown，Latex，IDL……

  > 数据格式描述语言 (DFDL) 1.0 是开放网格论坛中的一种建模语言，此语言用于以独立于数据格式的方式定义一般文本格式化数据和二进制格式化数据的结构。此语言基于 XML 模式 1.0。

* 编程语言：C，C++，Rust，Java，C#，Python，VB，Ruby，Perl，Lisp，JS，TS，Lua，Switft，Kotlin，Pascal，Clojure，F#……

  > 能够让程序员准确地定义计算机所需要使用数据的计算机语言，并精确地定义在不同情况下所应当采取的行动。

### 声明式和命令式

* 声明式语言：JSON，XML，XAML，HTML，SQL，CSS，YAML，ANLTR，MarkDown，Latex，IDL，Lisp，Hascall，Clojure，F#……

  > 只告诉你想要的结果（What），机器自己摸索过程（How）

* 命令式语言：C，C++，Rust，Java，C#，Python，VB，Ruby，Perl，JS，TS，Lua，Switft，Kotlin，Pascal……

  > 详细的命令机器怎么（How）去处理一件事情以达到你想要的结果（What）

## 语言的特性

### 图灵完备性

* 图灵完备性：在可计算性理论里，如果一系列操作数据的规则（如指令集、编程语言、细胞自动机）可以用来模拟单带图灵机，那么它是图灵完全的。这个词源于引入图灵机概念的数学家艾伦·图灵。虽然图灵机会受到储存能力的物理限制，图灵完全性通常指“具有无限存储能力的通用物理机器或编程语言”。
* 图灵机（Turing machine）：又称确定型图灵机，是英国数学家艾伦·图灵于 1936 年提出的一种将人的计算行为抽象掉的数学逻辑机，其更抽象的意义为一种计算模型，可以看作等价于任何有限逻辑数学过程的终极强大逻辑机器。

跟图灵机完全等效的就是图灵完备性，实现图灵完备性的两种方式：

> 所有可计算的问题都是可用来描述的语言

* 命令式 —— 图灵机 
  * goto
  * if和while
* 声明式 —— lambda
  * 递归

### [动态与静态](https://www.cnblogs.com/raind/p/8551791.html)

* 动态
  * 在用户的设备/在线服务器上运行
  * 产品实际运行时
  * Runtime（运行时）
* 静态
  * 在程序员的设备上
  * 产品开发时
  * compiletime（编译时）

### 类型系统

* 动态类型与静态类型
  * 用户的设备中可以找到的类型信息（动态 / 运行时）
  * 程序员的设备中才能找到类型信息（静态 / 编译时）
* 强类型与弱类型
  * 类型转换发生的形式
  * 强类型不会发生默认类型转换
* 复合类型
  * 结构体 => 对象
  * 函数签名（参数类型 + 返回值类型）
* 子类型
  * C++
  * 类跟类型是两种概念
* 泛型
  * 泛型+子类型 => [逆变 / 协变](https://jkchao.github.io/typescript-book-chinese/tips/covarianceAndContravariance.html)



## 一般命令式编程语言

* Atom（原子）
  * 语言最小组成单位
  * 包含关键字，直接量，变量名等基本单位
* Expression（表达式）
  * 原子级结构通过运算符相连接，加上一些辅助符号构成表达式的结构
  * 可以级联的结构
* Statement（语句）
  * 表达式加上标识符加上特性的符号或标识符构成语句
  * if语句 / for语句
* Structure（结构化）
  * function / class
  * 帮助组织代码，将代码分块，分为可以复用的结构
    * PASCAL（process）过程
    * C++（namespace）
* Program（组织代码）
  * 管理语言的模块和安装
  * program（实际执行的代码）
  * module（复用的模块）
  * package
  * library

## 语言讲解结构

* 语法
* 语义
* 运行时